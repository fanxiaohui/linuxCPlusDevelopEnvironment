AES CMAC 传输数据验证 加密算法由算法+模式+填充组成

为什么要实现AES CMAC 

CMAC 是消息认证码技术 
确保服务器接收到的数据没有被篡改 
确保服务器接收到的数据真正来自我的授权客户端

消息认证码是一种认证技术，它利用密钥来生成一个固定长度的端数据块，并将该数据块附加在消息之后。通信中，消息和MAC一起被发给接收方，接收方利用收到的信息及密钥进行计算，若得到新的MAC值和接受到的值相等，则认为

1）接收到的信息未被篡改：因攻击者没有密钥，故篡改信息之后，得不到对应的MAC值。(消息的完整性保护)

2）接收到的消息来自真正的发送方：攻击者没用密钥，不能生成MAC值。（保证信息的合法性）

在进行之前 
我们是AES-128 16字节128位加密（16乘以8=128）

首先明确 
第一 
	我们的根密钥设置为16字节的16进制数
第二 
	如果明文 超过16个字节  将进行拆分组 分成多个16字节的组 进行迭代的加密
第三 
	在AES算法中将对16字节的根密钥 进行扩展为密钥矩阵
	密钥矩阵为 11 行 
第四 
	在矩阵这里做了概念映射 我们实际上是每一行16字节
	但是在AES做矩阵运算时 将按照双字 进行运算
	一个字 两个字节 双字 四个字节 那么每一行四个字
	然后进行运算
第五 
	AES中的运算4种对该矩阵的操作 
	字节替代(SubBytes) 行移位(ShiftRows) 列混淆(MixColumns) 轮密钥加(AddRoundKey)

第六 
	AES在对我们的原始根密钥 或者 原始明文数据进行加密之前 需要先准备好 一个S盒矩阵 和一个S盒的逆 矩阵 而在S盒的详细构造方法有详细的规则约束 大部分公开的AES 都使用相同的S盒 如果想加密等级高自己设计S盒 应该是不错的选择


第七 
	AES流程
	明文输入 拆分为4*4矩阵的形式输入 input
	先经过⊕K0 （这里注意每回合都会由主密钥产生一把回合密钥）的操作
	成为AddRoundKey（Key与明文矩阵进行⊕操作。） 之后 再经过 ByteSub字节替换 ShiftRows行移位 MixColumn列混合 这一些列操作称为一个回合
	根据密钥的长短的不等总计 要通过10-14个回合后输出最后的密文

第八 
	假设明文分组P为”abcdefghijklmnop”
	明文矩阵 
	{
		{'a','e','i','m'}
		{'b','f','j','n'}
		{'c','g','k','o'}
		{'c','h','l','p'}
	}
	对应16进制表示该明文矩阵
	{
		{0x61,0x65,0x69,0x6D}
		{0x62,0x66,0x6A,0x6E}
		{0x63,0x67,0x6B,0x6F}
		{0x64,0x68,0x6C,0x70}
	}
	同样128位的16字节根密钥也将转换为这样的4*4矩阵
	{
		{0x71,0x85,0x99,0x1D}
		{0x72,0x86,0x9A,0x1E}
		{0x73,0x87,0x9B,0x1F}
		{0x74,0x88,0x9C,0x10}
	}
	注意这里开始定义 我们的矩阵论密钥加 字节代替 
	行移位 列混合 这些矩阵操作时AES操作的基本单位是字
	矩阵的每一列被称为1个32位比特字 一个双字

第九 
	AES 在拿到根密钥后 将进行（通过密钥扩展函数将根密钥扩展成一个44个字组成的序列W[0],W[1], … ,W[43],）密钥扩展 生成11 行16字节的密钥 但是AES 在做每一个回合的加密时
	对该密钥 矩阵进行转换为 44 个 双字 组成的序列来处理的，该序列的前4个元素是 原始根密钥本身

第十 
	行移位算法 公式
	state[i][j] = state[i][(j+i)%4];
	其中i、j属于[0,3]

	逆向行移位 公式
	state[i][j] = 
	state[i][(4+j-i)%4];其中i、j属于[0,3]

第十一 
	密钥扩展函数的算法 流程

	密钥扩展过程说明：

　　　　1) 将初始密钥以列为主，转化为4个32 bits的字，分别记为w[0…3]；

　　　　2) 按照如下方式，依次求解w[j]，其中j是整数并且属于[4,43]；

　　　　3) 若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]；

　　函数g的流程说明：

　　　　4) 将w循环左移一个字节；

　　　　5) 分别对每个字节按S盒进行映射；

　　　　6) 与32 bits的常量（RC[j/4],0,0,0）进行异或，RC是一个一维数组，其值如下。（RC的值只需要有10个，而此处用了11个，实际上RC[0]在运算中没有用到，增加RC[0]是为了便于程序中用数组表示。由于j的最小取值是4，j/4的最小取值则是1，因此不会产生错误。）

　　　　　　RC = {00, 01, 02, 04, 08, 10, 20, 40, 80, 1B, 36}

第十二 
	密钥填充算法

	项目上用到AES256加密解密算法，刚开始在java端加密解密都没有问题，在iOS端加密解密也没有问题。但是奇怪的是在java端加密后的文件在iOS端无法正确解密打开，然后简单测试了一下，发现在java端和iOS端采用相同明文，相同密钥加密后的密文不一样！上网查了资料后发现iOS中AES加密算法采用的填充是PKCS7Padding，而java不支持PKCS7Padding，只支持PKCS5Padding。我们知道加密算法由算法+模式+填充组成，所以这两者不同的填充算法导致相同明文相同密钥加密后出现密文不一致的情况。那么我们需要在java中用PKCS7Padding来填充，这样就可以和iOS端填充算法一致了。










